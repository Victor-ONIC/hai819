#version 460
#define M_PI 3.1415926535897932384626433832795
#define EPSI 0.001
#define NBCELL 9
#define NBBLUR 9

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(std430, binding = 0) buffer BlockData {
    uint data[]; // Le tableau de données
};

uniform int u_seed;
uniform int chunk_x;
uniform int chunk_z;
uniform int map_width;
uniform int map_height;
uniform int map_depth;
uniform float cell_size; // taille d'une cellule Voronoï

struct PerlinResult {
    float value;
    vec2 gradient;
};

struct BiomesData {
    uint id0;
    uint id1;
    float dist0;
    float dist1;
};

struct BiomeInfluence9{
    uint id[NBCELL];
    float dist[NBCELL];
};

uvec2 index2Dto1D(ivec2 coord, int width) {
    return uvec2(coord.y * width + coord.x, 0);
}

// Hash qui retourne un float entre 0.0 et 1.0
float hash12(ivec2 p) {
    uint h = uint(p.x * 374761393 + p.y * 668265263 + u_seed);
    h = (h ^ (h >> 13)) * 1274126177u;
    return float(h & 0xFFFFFFu) / float(0xFFFFFFu);
}

// Retourne une position locale du site Voronoï dans la cellule
vec2 voronoiSite(ivec2 cell) {
    return vec2(cell) * cell_size + vec2(hash12(cell), hash12(cell + ivec2(7, 3))) * cell_size;
}

uint cellID(ivec2 p) {
    uint h = uint(p.x) * 374761393u + uint(p.y) * 668265263u + uint(u_seed);
    h = (h ^ (h >> 13)) * 1274126177u;
    h ^= (h >> 16);
    return h;
}

// Fonction pour convertir (x, y, z) en un index 1D
uint index3DTo1D(uint x, uint y, uint z, uint width, uint height) {
    return x + y * width + z * (width * height);
}

float fade(float t) {
    return t*t*t*(t*(t*6.0-15.0)+10.0); // Improved fade, yields C2-continuous noise
}

float hash(int x, int y) {
    // Hash basé sur un mélange de bits
    int n = x * 374761393 + y * 668265263 + u_seed * 982451653; // nombres premiers
    n = (n ^ (n >> 13)) * 1274126177;
    return float((n ^ (n >> 16)) & 0x7fffffff) / float(0x7fffffff);
}

vec2 gradient(int x, int y) {
    float angle = hash(x, y) * 2 * M_PI;
    return vec2(cos(angle), sin(angle));
}

PerlinResult perlin_with_gradient(vec2 pos) {
    ivec2 p0 = ivec2(floor(pos));
    vec2 f = fract(pos);

    vec2 g00 = gradient(p0.x,     p0.y);
    vec2 g10 = gradient(p0.x + 1, p0.y);
    vec2 g01 = gradient(p0.x,     p0.y + 1);
    vec2 g11 = gradient(p0.x + 1, p0.y + 1);

    vec2 d00 = f - vec2(0.0, 0.0);
    vec2 d10 = f - vec2(1.0, 0.0);
    vec2 d01 = f - vec2(0.0, 1.0);
    vec2 d11 = f - vec2(1.0, 1.0);

    float v00 = dot(g00, d00);
    float v10 = dot(g10, d10);
    float v01 = dot(g01, d01);
    float v11 = dot(g11, d11);

    vec2 u = vec2(fade(f.x), fade(f.y));
    vec2 du = vec2(30.0 * f.x*f.x * (f.x - 1.0) * (f.x - 1.0),
                   30.0 * f.y*f.y * (f.y - 1.0) * (f.y - 1.0));

    float nx0 = mix(v00, v10, u.x);
    float nx1 = mix(v01, v11, u.x);
    float n = mix(nx0, nx1, u.y);

    // Gradient via la dérivée de l’interpolation
    vec2 dnoise_dxdy;
    dnoise_dxdy.x =
        mix(dot(g10, d10) - dot(g00, d00), dot(g11, d11) - dot(g01, d01), u.y) * du.x;
    dnoise_dxdy.y =
        mix(dot(g01, d01) - dot(g00, d00), dot(g11, d11) - dot(g10, d10), u.x) * du.y;

    return PerlinResult(n, dnoise_dxdy);
}

PerlinResult perlin_octaves(vec2 pos, int nb_octaves, float persistence, float zoom) {
    float total = 0.0;
    float amplitude = 1.0;
    float frequency = 1.0;
    float maxValue = 0.0; // pour normaliser
    PerlinResult result, tmp;
    result.value = 0.0;
    result.gradient = vec2(0.0);
    for (int i = 0; i < nb_octaves; ++i) {
        tmp = perlin_with_gradient(zoom * pos * frequency);
        result.value += tmp.value * amplitude;
        result.gradient += tmp.gradient * amplitude;
        maxValue += amplitude;
        amplitude *= persistence; // exemple : 0.5
        frequency *= 2.0;
    }
    return result;
}

BiomesData find_two_closest(vec2 world_pos) {
    BiomesData result;
    result.dist0 = 1e9;
    result.dist1 = 1e9;
    result.id0 = 0u;
    result.id1 = 0u;

    ivec2 cell_coord = ivec2(floor(world_pos / cell_size));
    for (int j = -1; j <= 1; ++j) {
        for (int i = -1; i <= 1; ++i) {
            ivec2 neighbor = cell_coord + ivec2(i, j);
            vec2 site_pos = voronoiSite(neighbor);
            float d = distance(world_pos, site_pos);
            uint id = cellID(neighbor);

            if (d < result.dist0) {
                // Décale l'ancien premier au second
                result.dist1 = result.dist0;
                result.id1 = result.id0;
                // Nouveau premier
                result.dist0 = d;
                result.id0 = id;
            } else if (d < result.dist1) {
                result.dist1 = d;
                result.id1 = id;
            }
        }
    }

    return result;
}

BiomeInfluence9 find_nine_closest(vec2 world_pos) {
    BiomeInfluence9 result;
    for (int i = 0; i < NBCELL; ++i) {
        result.dist[i] = 1e9;
        result.id[i] = 0u;
    }

    ivec2 cell_coord = ivec2(floor(world_pos / cell_size));
    for (int j = -1; j <= 1; ++j) {
        for (int i = -1; i <= 1; ++i) {
            ivec2 neighbor = cell_coord + ivec2(i, j);
            vec2 site_pos = voronoiSite(neighbor);
            float d = distance(world_pos, site_pos);
            uint id = cellID(neighbor);

            // Trouver la position d'insertion dans le tableau trié
            int insert_pos = NBCELL;
            for (int k = 0; k < NBCELL; ++k) {
                if (d < result.dist[k]) {
                    insert_pos = k;
                    break;
                }
            }

            // Si dans le top 9, on insère en décalant
            if (insert_pos < NBCELL) {
                for (int k = 8; k > insert_pos; --k) {
                    result.dist[k] = result.dist[k - 1];
                    result.id[k] = result.id[k - 1];
                }
                result.dist[insert_pos] = d;
                result.id[insert_pos] = id;
            }
        }
    }

    return result;
}

void main() {
    BiomesData biomes;
    PerlinResult noise;
    int nb_octaves = 2;
    float persistence = 0.5;
    float zoom = 0.01;
    ivec3 id = ivec3(gl_GlobalInvocationID.xyz);
    uvec3 global_id = gl_GlobalInvocationID.xyz;
    uint id1D = index3DTo1D(id.x, id.y, id.z, map_width, map_height);
    int gx = int(global_id.x) + chunk_x;
    int gz = int(global_id.z) + chunk_z;
    vec2 pos = vec2(gx, gz);
    noise = perlin_octaves(pos, nb_octaves, persistence, zoom);
    pos += noise.gradient * 20.0;
    vec2 world_pos = pos + vec2(0.5);
    float min_dist = 1e9;
    uint closest_id = 0u;

    ivec2 cell_coord = ivec2(floor(world_pos / cell_size));
    for (int j = -1; j <= 1; ++j) {
        for (int i = -1; i <= 1; ++i) {
            ivec2 neighbor = cell_coord + ivec2(i, j);
            vec2 site_pos = voronoiSite(neighbor);
            float d = distance(world_pos, site_pos);
            if (d <= min_dist) {
                min_dist = d;
                closest_id = cellID(neighbor);
            }
        }
    }


    BiomeInfluence9 bi = find_nine_closest(world_pos);
    float sum9 = 0.0;
    float total_weight = 0.0;
    float p = 6;

    for (int i = 0; i < NBBLUR; ++i) {
        float w = 1.0 / pow(bi.dist[i] + EPSI, p); // avec p ∈ [1.5, 3.0] typiquement
        total_weight += w;

        float biome_data = float(bi.id[i] % 2); // ou toute autre fonction
        sum9 += biome_data * w;
        //break;
    }

    float blended_biome = sum9 / total_weight;
/////////////////////////////////////////////////////

    biomes = find_two_closest(world_pos);

    // Poids inverses des distances
    float inv0 = 1.0 / (biomes.dist0 + EPSI); // évite div 0
    float inv1 = 1.0 / (biomes.dist1 + EPSI);
    float sum = inv0 + inv1;
    float w0 = inv0 / sum;
    float w1 = inv1 / sum;

// Interpolation linéaire des IDs (dans ton cas, simple uint % 4)
    float blended = w0 * float(biomes.id0 % 2u) + w1 * float(biomes.id1 % 2u);;
    //if((biomes.id0 % 2u) == 0) blended = float(w1);
    //else blended = float(w0);

    //blended = float(biomes.id0 %2u * w0);

    //data[id1D] = 4 + closest_id % 2;
    float val;
    float cellid = float(closest_id % 2);
    val = min_dist/cell_size;
    if((closest_id % 2) == 1) val *= -1;
    //data[id1D] = floatBitsToUint(val);
    data[id1D] = floatBitsToUint(blended_biome + EPSI);
}
