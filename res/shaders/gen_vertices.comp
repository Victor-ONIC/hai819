#version 460

struct face{
    uint blockype;        // 4 octets
    float _padding[3];    // 12 octets
    vec4 vert[4];         // 64 octets
    vec4 normal;          // 16 octets
    vec2 coord_tex[4];    // 32 octets
                          // 4 + 64 + 16 + 32 + 12 == 128 octets
};

uniform int map_width;
uniform int map_height;
uniform int map_depth;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
//layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) buffer BlockData {
    uint data[];
};

layout(std430, binding = 1) buffer FacesBuffer {
    face faces[];
};

layout(binding = 2, offset = 0) uniform atomic_uint facesCounter;

uint getBlock(int x, int y, int z) {
    if (x < 0 || y < 0 || z < 0 || x >= map_width || y >= map_height || z >= map_depth)
        return 0;
    return data[x + y * map_width + z * map_width * map_height];
}

vec3 offset[6] = vec3[6](
    vec3(-1,  0,  0), // -X
    vec3( 1,  0,  0), // +X
    vec3( 0, -1,  0), // -Y
    vec3( 0,  1,  0), // +Y
    vec3( 0,  0, -1), // -Z
    vec3( 0,  0,  1)  // +Z
);

vec3 faceVerts[6][4] = vec3[6][4](
    // -X
    vec3[4](vec3(0,0,0), vec3(0,1,0), vec3(0,0,1), vec3(0,1,1)),
    // +X
    vec3[4](vec3(1,0,1), vec3(1,1,1), vec3(1,0,0), vec3(1,1,0)),
    // -Y
    vec3[4](vec3(0,0,1), vec3(1,0,1), vec3(0,0,0), vec3(1,0,0)),
    // +Y
    vec3[4](vec3(0,1,0), vec3(1,1,0), vec3(0,1,1), vec3(1,1,1)),
    // -Z
    vec3[4](vec3(1,0,0), vec3(1,1,0), vec3(0,0,0), vec3(0,1,0)),
    // +Z
    vec3[4](vec3(0,0,1), vec3(0,1,1), vec3(1,0,1), vec3(1,1,1))
);

void emitFace(int f, vec3 pos, uint type) {
    //f = 5;
    uint index = atomicCounterAdd(facesCounter, 1);
    face newFace;
    newFace.blockype = type; // Ã€ adapter si tu veux utiliser `type` du voxel
    for (int i = 0; i < 4; ++i) {
        newFace.vert[i] = vec4(pos + faceVerts[f][i], 1.0);
    }
    newFace.normal = vec4(offset[f], 0.0); // normale de la face
    newFace.coord_tex[0] = vec2(0.0, 0.0);
    newFace.coord_tex[1] = vec2(1.0, 0.0);
    newFace.coord_tex[2] = vec2(0.0, 1.0);
    newFace.coord_tex[3] = vec2(1.0, 1.0);
    faces[index] = newFace;
}

// Fonction pour convertir (x, y, z) en un index 1D
int index3DTo1D(int x, int y, int z, int width, int height) {
    return x + y * width + z * (width * height);
}

bool is_edge(int x, int y, int z){
    if(x==0 || y==0 || z==0) return true;
    if(x==map_width || y==map_height || z==map_depth) return true;
    return false;
}

void main() {
    ivec3 id = ivec3(gl_GlobalInvocationID.xyz);
    if (id.x >= map_width || id.y >= map_height || id.z >= map_depth) return;
    uint index = index3DTo1D(id.x, id.y, id.z, map_width, map_height);
    uint type = data[index];
    if (type == 0) return;
    //if (is_edge(id.x, id.y, id.z) && (type == 2)) return;
    //if (is_edge(id.x, id.y, id.z)) return;

    for (int f = 0; f < 6; ++f) {
        ivec3 neighbor = id + ivec3(offset[f]);
        uint neighbor_type = getBlock(neighbor.x, neighbor.y, neighbor.z);
        if (neighbor_type == 0 || (neighbor_type != type && type == 1)) {
            emitFace(f, vec3(id), type);
        }
    }
}
