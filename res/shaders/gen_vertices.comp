#version 460

struct face{
    uint blockype;       // 4 octets
    uvec3 _pad0;         // 12 octets    -> PADDING
    vec4 vert[4];        // 64 octets
    vec4 normal;         // 16 octets
    vec2 coord_tex;      // 8 octets
    vec2 _pad1;          // 8 octets     -> PADDING
                         // 64 + 16 + 16 + 16 == 112 octets
};

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(std430, binding = 0) readonly buffer BlockData {
    uint data[];
};

layout(std430, binding = 1) writeonly buffer FacesBuffer {
    face faces[];
};

layout(binding = 2, offset = 0) uniform atomic_uint vertexCounter;

uniform int map_width;
uniform int map_height;
uniform int map_depth;

uint getBlock(int x, int y, int z) {
    if (x < 0 || y < 0 || z < 0 || x >= map_width || y >= map_height || z >= map_depth)
        return 0;
    return data[x + y * map_width + z * map_width * map_height];
}

vec3 offset[6] = vec3[6](
    vec3(-1,  0,  0), // -X
    vec3( 1,  0,  0), // +X
    vec3( 0, -1,  0), // -Y
    vec3( 0,  1,  0), // +Y
    vec3( 0,  0, -1), // -Z
    vec3( 0,  0,  1)  // +Z
);

vec3 faceVerts[6][4] = vec3[6][4](
    // -X
    vec3[4](vec3(0,0,0), vec3(0,1,0), vec3(0,0,1), vec3(0,1,1)),
    // +X
    vec3[4](vec3(1,0,1), vec3(1,1,1), vec3(1,0,0), vec3(1,1,0)),
    // -Y
    vec3[4](vec3(0,0,1), vec3(1,0,1), vec3(0,0,0), vec3(1,0,0)),
    // +Y
    vec3[4](vec3(0,1,0), vec3(1,1,0), vec3(0,1,1), vec3(1,1,1)),
    // -Z
    vec3[4](vec3(1,0,0), vec3(1,1,0), vec3(0,0,0), vec3(0,1,0)),
    // +Z
    vec3[4](vec3(0,0,1), vec3(0,1,1), vec3(1,0,1), vec3(1,1,1))
);


void emitFace(int f, vec3 pos, uint type) {
    uint index = atomicCounterAdd(vertexCounter, 1);

    face newFace;
    newFace.blockype = type; // À adapter si tu veux utiliser `type` du voxel
    newFace._pad0 = uvec3(0); // Juste du padding
    for (int i = 0; i < 4; ++i) {
        newFace.vert[i] = vec4(pos + faceVerts[f][i], 1.0);
    }

    newFace.normal = vec4(offset[f], 0.0); // normale de la face
    newFace.coord_tex = vec2(0.0, 0.0);    // exemple simple, à adapter selon ton atlas
    newFace._pad1 = vec2(0.0);             // padding

    faces[index] = newFace;
}


void main() {
    ivec3 id = ivec3(gl_GlobalInvocationID.xyz);
    if (id.x >= map_width || id.y >= map_height || id.z >= map_depth)
        return;

    uint index = id.x + id.y * map_width + id.z * map_width * map_height;
    uint type = data[index];
    if (type == 0) return;

    for (int f = 0; f < 6; ++f) {
        ivec3 neighbor = id + ivec3(offset[f]);
        if (getBlock(neighbor.x, neighbor.y, neighbor.z) == 0) {
            emitFace(f, vec3(id), type);
        }
    }
}
