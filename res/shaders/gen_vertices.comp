#version 460

struct face{
    uint blockype;        // 4 octets
    vec4 vert[4];         // 64 octets
    vec4 normal;          // 16 octets
    vec2 coord_tex[4];    // 32 octets
    float _padding[3];    // 12 octets
                          // 4 + 64 + 16 + 32 + 12 == 128 octets
};

uniform int map_width;
uniform int map_height;
uniform int map_depth;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(std430, binding = 0) buffer BlockData {
    uint data[];
};

layout(std430, binding = 1) buffer FacesBuffer {
    face faces[];
};

layout(binding = 2, offset = 0) uniform atomic_uint facesCounter;

uint getBlock(int x, int y, int z) {
    if (x < 0 || y < 0 || z < 0 || x >= map_width || y >= map_height || z >= map_depth)
        return 0;
    return data[x + y * map_width + z * map_width * map_height];
}

vec3 offset[6] = vec3[6](
    vec3(-1,  0,  0), // -X
    vec3( 1,  0,  0), // +X
    vec3( 0, -1,  0), // -Y
    vec3( 0,  1,  0), // +Y
    vec3( 0,  0, -1), // -Z
    vec3( 0,  0,  1)  // +Z
);

vec3 faceVerts[6][4] = vec3[6][4](
    // -X
    vec3[4](vec3(0,0,0), vec3(0,1,0), vec3(0,0,1), vec3(0,1,1)),
    // +X
    vec3[4](vec3(1,0,1), vec3(1,1,1), vec3(1,0,0), vec3(1,1,0)),
    // -Y
    vec3[4](vec3(0,0,1), vec3(1,0,1), vec3(0,0,0), vec3(1,0,0)),
    // +Y
    vec3[4](vec3(0,1,0), vec3(1,1,0), vec3(0,1,1), vec3(1,1,1)),
    // -Z
    vec3[4](vec3(1,0,0), vec3(1,1,0), vec3(0,0,0), vec3(0,1,0)),
    // +Z
    vec3[4](vec3(0,0,1), vec3(0,1,1), vec3(1,0,1), vec3(1,1,1))
);

void emitFace(int f, vec3 pos, uint type) {
    uint index = atomicCounterAdd(facesCounter, 1);
    face newFace;
    newFace.blockype = type; // À adapter si tu veux utiliser `type` du voxel
    newFace._pad0 = uvec3(0); // Juste du padding
    for (int i = 0; i < 4; ++i) {
        newFace.vert[i] = vec4(pos + faceVerts[f][i], 1.0);
    }
    newFace.normal = vec4(offset[f], 0.0); // normale de la face
    newFace.coord_tex = vec2(0.0, 0.0);    // exemple simple, à adapter selon ton atlas
    newFace._pad1 = vec2(0.0);             // padding
    faces[index] = newFace;
}

// Fonction pour convertir (x, y, z) en un index 1D
int index3DTo1D(int x, int y, int z, int width, int height) {
    return x + y * width + z * (width * height);
}

void main() {
    ivec3 id = ivec3(gl_GlobalInvocationID.xyz);
    if (id.x >= map_width || id.y >= map_height || id.z >= map_depth)
        return;

    uint index = index3DTo1D(id.x, id.y, id.z, map_width, map_height);
    uint type = data[index];
    if (type == 0) return;

    for (int f = 0; f < 6; ++f) {
        ivec3 neighbor = id + ivec3(offset[f]);
        if (getBlock(neighbor.x, neighbor.y, neighbor.z) == 0) {
            emitFace(f, vec3(id), type);
        }
    }
}
