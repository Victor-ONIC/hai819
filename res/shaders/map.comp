#version 460
#define M_PI 3.1415926535897932384626433832795
#define EPSI 0.001
#define NBCELL 4
#define NBBLUR 3
#define POW 9.0

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(std430, binding = 0) buffer BlockData {
    uint data[]; // Le tableau de données
};

uniform int u_seed;
uniform int chunk_x;
uniform int chunk_z;
uniform int map_width;
uniform int map_height;
uniform int map_depth;
uniform float cell_size; // taille d'une cellule Voronoï

struct BiomeInfluence9{
    uint id[NBCELL];
    float dist[NBCELL];
};

struct BiomesParam{
    int nb_octaves;
    float persistence;
    float zoom;
    float ground_height;
    float coef_pow;
    int bool_pow;
    int bool_inver;
    uint base_block;
    float noise_result;
};

struct PerlinResult {
    float value;
    vec2 gradient;
};

float fade(float t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0); // Improved fade, yields C2-continuous noise
}

float hash(int x, int y) {
    // Hash basé sur un mélange de bits
    int n = x * 374761393 + y * 668265263 + u_seed * 982451653; // nombres premiers
    n = (n ^ (n >> 13)) * 1274126177;
    return float((n ^ (n >> 16)) & 0x7fffffff) / float(0x7fffffff);
}

// Hash qui retourne un float entre 0.0 et 1.0
float hash12(ivec2 p) {
    uint h = uint(p.x * 374761393 + p.y * 668265263 + u_seed);
    h = (h ^ (h >> 13)) * 1274126177u;
    return float(h & 0xFFFFFFu) / float(0xFFFFFFu);
}

uint cellID(ivec2 p) {
    uint h = uint(p.x) * 374761393u + uint(p.y) * 668265263u + uint(u_seed);
    h = (h ^ (h >> 13)) * 1274126177u;
    h ^= (h >> 16);
    return h;
}

vec2 gradient(int x, int y) {
    float angle = hash(x, y) * 2 * M_PI;
    return vec2(cos(angle), sin(angle));
}

PerlinResult perlin_with_gradient(vec2 pos, float coef_pow, int bool_pow) {
    ivec2 p0 = ivec2(floor(pos));
    vec2 f = fract(pos);

    vec2 g00 = gradient(p0.x,     p0.y);
    vec2 g10 = gradient(p0.x + 1, p0.y);
    vec2 g01 = gradient(p0.x,     p0.y + 1);
    vec2 g11 = gradient(p0.x + 1, p0.y + 1);

    vec2 d00 = f - vec2(0.0, 0.0);
    vec2 d10 = f - vec2(1.0, 0.0);
    vec2 d01 = f - vec2(0.0, 1.0);
    vec2 d11 = f - vec2(1.0, 1.0);

    float v00 = dot(g00, d00);
    float v10 = dot(g10, d10);
    float v01 = dot(g01, d01);
    float v11 = dot(g11, d11);

    vec2 u = vec2(fade(f.x), fade(f.y));
    vec2 du = vec2(30.0 * f.x*f.x * (f.x - 1.0) * (f.x - 1.0),
                   30.0 * f.y*f.y * (f.y - 1.0) * (f.y - 1.0));

    float nx0 = mix(v00, v10, u.x);
    float nx1 = mix(v01, v11, u.x);
    float n = mix(nx0, nx1, u.y);
    if(bool_pow == 1) n = pow(abs(n), coef_pow); // Réduit les zones plates

    // Gradient via la dérivée de l’interpolation
    vec2 dnoise_dxdy;
    dnoise_dxdy.x =
        mix(dot(g10, d10) - dot(g00, d00), dot(g11, d11) - dot(g01, d01), u.y) * du.x;
    dnoise_dxdy.y =
        mix(dot(g01, d01) - dot(g00, d00), dot(g11, d11) - dot(g10, d10), u.x) * du.y;

    return PerlinResult(n, dnoise_dxdy);
}

float perlin(vec2 pos) {
    ivec2 p0 = ivec2(floor(pos));
    vec2 f = fract(pos);

    vec2 g00 = gradient(p0.x, p0.y);
    vec2 g10 = gradient(p0.x + 1, p0.y);
    vec2 g01 = gradient(p0.x, p0.y + 1);
    vec2 g11 = gradient(p0.x + 1, p0.y + 1);

    float d00 = dot(g00, f - vec2(0.0, 0.0));
    float d10 = dot(g10, f - vec2(1.0, 0.0));
    float d01 = dot(g01, f - vec2(0.0, 1.0));
    float d11 = dot(g11, f - vec2(1.0, 1.0));

    vec2 u = vec2(fade(f.x), fade(f.y));

    float mix_x1 = mix(d00, d10, u.x);
    float mix_x2 = mix(d01, d11, u.x);
    return mix(mix_x1, mix_x2, u.y);
}
// Fonction pour convertir (x, y, z) en un index 1D
uint index3DTo1D(uint x, uint y, uint z, uint width, uint height) {
    return x + y * width + z * (width * height);
}

vec3 normalize_id(ivec3 id, uint width, uint height, uint depth){
    return vec3(float(id.x) / float(width), float(id.y) / float(height), float(id.z) / float(depth));
}

uint compute_2D(float noise, float ground_height, float ind3D_y, uint biome_type){
    if((noise * (1.0 - ground_height) + ground_height) > ind3D_y) return biome_type;
    return 0;
}


float perlin_octaves(vec2 pos, BiomesParam biome) {
    int nb_octaves = biome.nb_octaves;
    float persistence = biome.persistence;
    float zoom = biome.zoom;
    float coef_pow = biome.coef_pow;
    int bool_pow = biome.bool_pow;
    PerlinResult result, tmp;
    result.value = 0.0;
    result.gradient = vec2(0.0);
    float total = 0.0;
    float amplitude = 1.0;
    float frequency = 1.0;
    float maxValue = 0.0; // pour normaliser
    for (int i = 0; i < nb_octaves; ++i) {
        //total += perlin(zoom * pos * frequency) * amplitude;
        tmp = perlin_with_gradient(zoom * pos * frequency, coef_pow, bool_pow);
        result.value += tmp.value * amplitude;
        maxValue += amplitude;
        amplitude *= persistence; // exemple : 0.5
        frequency *= 2.0;
    }
    return (result.value / maxValue);
}

// Retourne une position locale du site Voronoï dans la cellule
vec2 voronoiSite(ivec2 cell) {
    return vec2(cell) * cell_size + vec2(hash12(cell), hash12(cell + ivec2(7, 3))) * cell_size;
}

BiomeInfluence9 find_nine_closest(vec2 world_pos) {
    BiomeInfluence9 result;
    for (int i = 0; i < NBCELL; ++i) {
        result.dist[i] = 1e9;
        result.id[i] = 0u;
    }

    ivec2 cell_coord = ivec2(floor(world_pos / cell_size));
    for (int j = -1; j <= 1; ++j) {
        for (int i = -1; i <= 1; ++i) {
            ivec2 neighbor = cell_coord + ivec2(i, j);
            vec2 site_pos = voronoiSite(neighbor);
            float d = distance(world_pos, site_pos);
            uint id = cellID(neighbor);

            // Trouver la position d'insertion dans le tableau trié
            int insert_pos = NBCELL;
            for (int k = 0; k < NBCELL; ++k) {
                if (d < result.dist[k]) {
                    insert_pos = k;
                    break;
                }
            }

            // Si dans le top 9, on insère en décalant
            if (insert_pos < NBCELL) {
                for (int k = 8; k > insert_pos; --k) {
                    result.dist[k] = result.dist[k - 1];
                    result.id[k] = result.id[k - 1];
                }
                result.dist[insert_pos] = d;
                result.id[insert_pos] = id;
            }
        }
    }

    return result;
}

void main()
{
    BiomesParam lava;
    BiomesParam hill;
    BiomesParam sable;
    BiomesParam biome;
    ivec3 id = ivec3(gl_GlobalInvocationID.xyz);
    uint id1D = index3DTo1D(id.x, id.y, id.z, map_width, map_height);
    vec3 ind3D = normalize_id(id, map_width, map_height, map_depth);
    uvec3 global_id = gl_GlobalInvocationID.xyz;
    int gx = int(global_id.x) + chunk_x;
    int gz = int(global_id.z) + chunk_z;
    vec2 pos = vec2(gx, gz) * 0.004;
    vec2 world_pos = vec2(gx, gz) + vec2(0.5);


    hill.nb_octaves = 9;
    hill.persistence = 0.5;
    hill.zoom = 1.0;
    hill.ground_height = 0.3;
    hill.coef_pow = 0.40;
    hill.bool_pow = 0;
    hill.bool_inver = 0;
    hill.base_block = 1;

    lava.nb_octaves = 9;
    lava.persistence = 0.5;
    lava.zoom = 0.3;
    lava.ground_height = 0.0;
    lava.coef_pow = 0.40;
    lava.bool_pow = 1;
    lava.bool_inver = 1;
    lava.base_block = 4;

    sable.nb_octaves = 3;
    sable.persistence = 1.5;
    sable.zoom = 0.2;
    sable.ground_height = 0.0;
    sable.coef_pow = 0.80;
    sable.bool_pow = 1;
    sable.bool_inver = 1;
    sable.base_block = 6;

    BiomesParam all_biomes[3];
    all_biomes[0] = hill;
    all_biomes[1] = lava;
    all_biomes[2] = sable;
    BiomeInfluence9 bi = find_nine_closest(world_pos);
    float sum9 = 0.0;
    float total_weight = 0.0;

    for (int i = 0; i < NBBLUR; ++i) {
        float w = 1.0 / pow(bi.dist[i] + EPSI, POW); // avec p ∈ [1.5, 3.0] typiquement
        total_weight += w;

        float biome_data = float(bi.id[i] % 2); // ou toute autre fonction
        sum9 += biome_data * w;
    }

    float blended_biome = sum9 / total_weight;

    for(int i = 0; i < 2 ; ++i){
        all_biomes[i].noise_result = perlin_octaves(pos, all_biomes[i]);
        if(all_biomes[i].bool_inver == 1) all_biomes[i].noise_result = 1.0 - all_biomes[i].noise_result;
    }

    uint biome_ind =  bi.id[0] % 2;
    uint base_block = all_biomes[biome_ind].base_block;
    float result;
    float ground_height;
    //blended_biome = 1.0;

    result = blended_biome * all_biomes[biome_ind].noise_result + (1.0 - blended_biome) * all_biomes[(biome_ind+1)%2].noise_result;
    ground_height = blended_biome * all_biomes[biome_ind].ground_height + (1.0 - blended_biome) * all_biomes[(biome_ind+1)%2].ground_height;

    data[id1D] = 0;
    data[id1D] = compute_2D(result, ground_height, ind3D.y, base_block);
}
