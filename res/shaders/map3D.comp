#version 460
#define M_PI 3.1415926535897932384626433832795

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(std430, binding = 0) buffer BlockData {
    uint data[]; // Le tableau de données
};

uniform int u_seed;
uniform int chunk_x;
uniform int chunk_z;
uniform int map_width;
uniform int map_height;
uniform int map_depth;

float fade(float t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0); // Improved fade, yields C2-continuous noise
}

// Fonction pour convertir (x, y, z) en un index 1D
uint index3DTo1D(uint x, uint y, uint z, uint width, uint height) {
    return x + y * width + z * (width * height);
}

vec3 normalize_id(ivec3 id, uint width, uint height, uint depth){
    return vec3(float(id.x) / float(width), float(id.y) / float(height), float(id.z) / float(depth));
}

uint compute_2D(float noise, float ground_height, float ind3D_y){
    if((noise / 4.0) + ground_height > ind3D_y) return 1;
    return 0;
}

float hash(int x, int y, int z) {
    int n = x * 374761393 + y * 668265263 + z * 2147483647 + u_seed * 982451653;
    n = (n ^ (n >> 13)) * 1274126177;
    return float((n ^ (n >> 16)) & 0x7fffffff) / float(0x7fffffff);
}

vec3 gradient(int x, int y, int z) {
    float theta = hash(x, y, z) * 6.2831853; // 2π
    float phi = hash(x + 1, y + 1, z + 1) * 3.14159265; // π
    float xg = cos(theta) * sin(phi);
    float yg = sin(theta) * sin(phi);
    float zg = cos(phi);
    return vec3(xg, yg, zg);
}

float perlin(vec3 pos) {
    ivec3 p0 = ivec3(floor(pos));
    vec3 f = fract(pos);

    vec3 g000 = gradient(p0.x,     p0.y,     p0.z);
    vec3 g100 = gradient(p0.x + 1, p0.y,     p0.z);
    vec3 g010 = gradient(p0.x,     p0.y + 1, p0.z);
    vec3 g110 = gradient(p0.x + 1, p0.y + 1, p0.z);
    vec3 g001 = gradient(p0.x,     p0.y,     p0.z + 1);
    vec3 g101 = gradient(p0.x + 1, p0.y,     p0.z + 1);
    vec3 g011 = gradient(p0.x,     p0.y + 1, p0.z + 1);
    vec3 g111 = gradient(p0.x + 1, p0.y + 1, p0.z + 1);

    float d000 = dot(g000, f - vec3(0.0, 0.0, 0.0));
    float d100 = dot(g100, f - vec3(1.0, 0.0, 0.0));
    float d010 = dot(g010, f - vec3(0.0, 1.0, 0.0));
    float d110 = dot(g110, f - vec3(1.0, 1.0, 0.0));
    float d001 = dot(g001, f - vec3(0.0, 0.0, 1.0));
    float d101 = dot(g101, f - vec3(1.0, 0.0, 1.0));
    float d011 = dot(g011, f - vec3(0.0, 1.0, 1.0));
    float d111 = dot(g111, f - vec3(1.0, 1.0, 1.0));

    vec3 u = vec3(fade(f.x), fade(f.y), fade(f.z));

    float x00 = mix(d000, d100, u.x);
    float x10 = mix(d010, d110, u.x);
    float x01 = mix(d001, d101, u.x);
    float x11 = mix(d011, d111, u.x);

    float y0 = mix(x00, x10, u.y);
    float y1 = mix(x01, x11, u.y);

    return mix(y0, y1, u.z);
}

float perlin_octaves(vec3 pos, int nb_octaves, float persistence, float zoom) {
    float total = 0.0;
    float amplitude = 1.0;
    float frequency = 1.0;
    float maxValue = 0.0;

    for (int i = 0; i < nb_octaves; ++i) {
        total += perlin(zoom * pos * frequency) * amplitude;
        maxValue += amplitude;
        amplitude *= persistence;
        frequency *= 2.0;
    }
    return total / maxValue;
}

uint compute_3D(vec3 ind3D, uint type, float noise){
    if((noise > 0.25) && (type == 1 || type == 3)) return 0;
    return type;
}

void main()
{
    ivec3 id = ivec3(gl_GlobalInvocationID.xyz);
    uint id1D = index3DTo1D(id.x, id.y, id.z, map_width, map_height);
    float ground_height = 0.25;
    uvec3 global_id = gl_GlobalInvocationID.xyz;
    int nb_octaves = 9;
    float persistence = 0.5;
    float zoom = 0.10;

    int gx = int(global_id.x) + chunk_x;
    int gy = int(global_id.y);
    int gz = int(global_id.z) + chunk_z;
    vec3 pos = vec3(gx, gy, gz) * 0.04;
    float value = perlin_octaves(pos, nb_octaves, persistence, zoom);
    data[id1D] = compute_3D(pos, data[id1D], value);
}
